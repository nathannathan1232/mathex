// Generated by CoffeeScript 1.9.3
(function() {
  var Node, OPERATORS, get_block, get_next_param, is_function_define, is_one_function_call, least_important_operator, parse, parse_line, parse_params, priority, remove_padding, split_at_index, split_by_line;

  Node = (function() {
    function Node(type, value) {
      this.type = type;
      this.value = value;
    }

    return Node;

  })();

  OPERATORS = [['=', ':=', '+=', '-=', '*=', '/=', '%=', '.='], ['^'], ['&&', '&'], ['||', '|'], ['>', '<', '==', '!=', '>=', '<=', '~~'], ['.'], ['<<', '>>'], ['+', '-'], ['*', '/', '%'], ['**']];

  priority = function(op) {
    var i, k, ref;
    for (i = k = 0, ref = OPERATORS.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      if (OPERATORS[i].includes(op)) {
        return i;
      }
    }
  };

  remove_padding = function(tokens) {
    if (['open_parinthesis', 'close_parinthesis'].includes(tokens[0].type)) {
      tokens.shift();
    }
    if (['open_parinthesis', 'close_parinthesis'].includes(tokens[tokens.length - 1].type)) {
      return tokens.pop();
    }
  };

  is_one_function_call = function(tokens) {
    var i, indents, k, ref;
    indents = 0;
    for (i = k = 0, ref = tokens.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      if (['open_parinthesis', 'function_call'].includes(tokens[i].type)) {
        indents += 1;
      } else if (['close_parinthesis'].includes(tokens[i].type)) {
        indents -= 1;
      }
      if (indents < 1 && i > 0 && i < tokens.length - 1) {
        return false;
      }
    }
    if (tokens[0].type === 'function_call') {
      return true;
    }
  };

  is_function_define = function(tokens) {
    var i, k, len;
    for (k = 0, len = tokens.length; k < len; k++) {
      i = tokens[k];
      if (i.type === 'function_define') {
        return true;
      }
    }
    return false;
  };

  least_important_operator = function(tokens) {
    var i, indents, index, k, p, ref;
    index = 0;
    p = Infinity;
    indents = 1;
    for (i = k = 0, ref = tokens.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      if (tokens[i].type === 'operator' && priority(tokens[i].value) * indents < p) {
        index = i;
        p = priority(tokens[i].value) * indents;
      } else if (['open_parinthesis', 'function_call'].includes(tokens[i].type)) {
        indents += 1;
      } else if (['close_parinthesis'].includes(tokens[i].type)) {
        indents -= 1;
      }
    }
    return index;
  };

  split_at_index = function(tokens, i) {
    var j, k, left, ref;
    tokens = JSON.parse(JSON.stringify(tokens));
    left = [];
    for (j = k = 0, ref = i; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {
      left.push(tokens.shift());
    }
    tokens.shift();
    return [left, tokens];
  };

  split_by_line = function(tokens) {
    var res;
    tokens = JSON.parse(JSON.stringify(tokens));
    res = [];
    while (tokens.length > 0) {
      res.push([]);
      while (!(tokens.length < 1 || tokens[0].type === 'line_end')) {
        res[res.length - 1].push(tokens.shift());
      }
      tokens.shift();
    }
    return res;
  };

  get_block = function(tokens) {
    var indents, stack;
    stack = [];
    indents = 0;
    while (tokens.length > 0 && indents >= 0) {
      switch (tokens[0].type) {
        case 'block_start':
          indents += 1;
          break;
        case 'block_end':
          indents -= 1;
      }
      stack.push(tokens.shift());
    }
    return stack;
  };

  get_next_param = function(tokens) {
    var indents, stack;
    stack = [];
    indents = 0;
    while (tokens.length > 0) {
      if (['open_parinthesis', 'function_call'].includes(tokens[0].type)) {
        indents += 1;
      } else if (['close_parinthesis'].includes(tokens[0].type)) {
        indents -= 1;
      }
      if ((tokens[0].type === 'comma' && indents < 1) || tokens.length < 1) {
        tokens.shift();
        return stack;
      }
      stack.push(tokens.shift());
    }
    return stack;
  };

  parse_params = function(tokens) {
    var res;
    res = [];
    while (tokens.length > 0) {
      res.push(parse_line(get_next_param(tokens)));
    }
    return res;
  };

  parse_line = function(tokens) {
    var fn, index, left, node, op, right, split, stack;
    remove_padding(tokens);
    if (tokens[0].type === 'keyword') {
      node = new Node('conditional', tokens[0].value);
      tokens.shift();
      stack = [];
      while (tokens[0].type !== 'block_start') {
        stack.push(tokens.shift());
      }
      node.times = parse_line(stack);
      tokens.shift();
      stack = get_block(tokens);
      stack.pop();
      node.block = new Node('block', '');
      node.block.children = parse(stack);
      return node;
    }
    stack = [];
    while (!(tokens.length < 1 || tokens[0].type === 'line_end')) {
      stack.push(tokens.shift());
    }
    tokens.shift();
    tokens = stack;
    if (tokens[0].type === 'annotation') {
      node = new Node('annotation', tokens[0].value);
      node.ref = tokens[1].value;
      return node;
    }
    if (is_function_define(tokens)) {
      node = new Node('function_define', tokens[0].value.replace(/\($/, ''));
      tokens.shift();
      node.params = [];
      while (tokens[0].type !== 'function_define') {
        node.params.push(tokens.shift().value);
        tokens.shift();
      }
      tokens.shift();
      node.block = parse_line(tokens);
      return node;
    }
    if (is_one_function_call(tokens)) {
      fn = tokens[0].value.replace(/\($/, '');
      node = new Node(tokens[0].type, fn);
      tokens.shift();
      node.params = parse_params(tokens);
      return node;
    }
    if (tokens.length === 1) {
      node = new Node(tokens[0].type, tokens[0].value);
      return node;
    }
    index = least_important_operator(tokens);
    op = tokens[index].value;
    split = split_at_index(tokens, index);
    left = parse_line(split[0]);
    right = parse_line(split[1]);
    node = new Node('binary_operation', op);
    node.left = left;
    node.right = right;
    return node;
  };

  parse = function(tokens) {
    var block;
    block = [];
    while (tokens.length > 0) {
      block.push(parse_line(tokens));
    }
    return block;
  };

  module.exports = parse;

}).call(this);
